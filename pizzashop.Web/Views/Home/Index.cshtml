@{
    ViewData["Title"] = "Dashboard Page";
}

<link rel="stylesheet" href="~/css/Menu.css" />

<div class="container-fluid main-content px-5 mt-50px">

    <div class="mb-2 d-flex justify-content-between align-items-md-center flex-md-row flex-column">
        <div class="heading-text py-2">
            <h1><b>Dashboard</b></h1>
        </div>

        <div class="pt-3">
            <div class="form-floating" style="height:60px">
                <select class="form-select form-control" id="time-main-filter"
                    aria-label="Floating label select example">
                    <option selected value="all">All Time</option>
                    <option value="today">Today</option>
                    <option value="7">Last 7 Days</option>
                    <option value="30">Last 30 Days</option>
                    <option value="currentMonth">Current Month</option>
                    <option value="customdate">Custom Date</option>
                    <option value="0" class="d-none">Custom Date</option>
                </select>
                <label>Duration</label>
            </div>
        </div>
    </div>

    <div class="dashboard-partial"></div>

</div>

<div class="modal fade modal-delete" id="customDateModal" tabindex="-1" aria-labelledby="deleteModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="customDateModal">Select Data Range</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body d-flex gap-2 flex-row align-items-center justify-content-center">
                <div class="form-floating w-50">
                    <input type="date" class="form-control" id="FromDate" max="" placeholder="fromDate">
                    <label for="fromDate">From Date</label>
                </div>

                <div class="form-floating w-50">
                    <input type="date" class="form-control" id="ToDate" max="" placeholder="ToDate">
                    <label for="ToDate">To Date</label>
                </div>
            </div>

            <div class="modal-footer d-flex justify-content-center gap-2">
                <a id="serachDate">
                    <button type="button" class="search-btn" style="background: #087cc4; color:white; 
                    border:1px solid #087cc4; border-radius: 5px;">Submit</button>
                </a>
                <button type="button" class="clear-btn" data-bs-dismiss="modal" style="background: white; 
                color:#087cc4; border:1px solid #087cc4; border-radius: 5px;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>

    let GDFromDate;
    let GDToDate;
    let revenueChartInstance;
    let customerChartInstance;
    let lastSelectedFilter = null;


    function formatDate(date) {
        return date.toISOString().split("T")[0];
    }

    function renderRevenueChart(data) {
        const ctx = document.getElementById('revenueChart').getContext('2d');
        if (window.revenueChartInstance) window.revenueChartInstance.destroy();

        // 1) parse incoming dates
        data.forEach(d => d.date = new Date(d.date));
        let dateFilter = $('#time-main-filter').val();

        // 2) decide grouping mode
        let mode;
        if (!GDFromDate || !GDToDate || dateFilter === "all") {
            // ----> ALL TIME: group by actual data span
            const dates = data.map(d => d.date.getTime());
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            const sameDay = minDate.toDateString() === maxDate.toDateString();
            const sameMonth = minDate.getFullYear() === maxDate.getFullYear()
                && minDate.getMonth() === maxDate.getMonth();
            const sameYear = minDate.getFullYear() === maxDate.getFullYear();

            if (sameDay) mode = 'hour';
            else if (sameMonth) mode = 'day';
            else if (sameYear) mode = 'month';
            else mode = 'monthYear';
        }
        else {
            // ----> FILTERED: use GDFromDate/GDToDate + dateFilter
            const from = new Date(GDFromDate),
                to = new Date(GDToDate);
            const sameDay = from.toDateString() === to.toDateString();
            const sameMonth = from.getFullYear() === to.getFullYear()
                && from.getMonth() === to.getMonth();
            const sameYear = from.getFullYear() === to.getFullYear();

            if (dateFilter === 'today') mode = 'hour';
            else if (dateFilter === '7' || dateFilter === '30' || dateFilter === 'currentMonth')
                mode = 'day';
            else /* customdate */ {
                if (sameDay) mode = 'hour';
                else if (sameMonth) mode = 'day';
                else if (sameYear) mode = 'month';
                else mode = 'monthYear';
            }
        }

        // 3) build labels+groups exactly as before...
        let labels = [], grouped = {};
        let dateMap = {}; // for day mode: DD-MM format
        if (mode === 'hour') {
            for (let h = 0; h < 24; h++) { labels.push(`${h}:00`); grouped[h] = 0; }
            data.forEach(d => grouped[d.date.getHours()] += d.totalRevenue);
        }
        else if (mode === 'day') {
            let from, to;
            if (dateFilter === "currentMonth") {
                const today = new Date();
                from = new Date(today.getFullYear(), today.getMonth(), 1);
                to = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            } else {
                from = new Date(GDFromDate);
                to = new Date(GDToDate);
            }

            for (let dt = new Date(from); dt <= to; dt.setDate(dt.getDate() + 1)) {
                const dateStr = dt.toISOString().split('T')[0]; // yyyy-MM-dd
                grouped[dateStr] = 0;
                // Changed to "DD-MM" format
                const day = dt.getDate().toString().padStart(2, '0');
                const month = (dt.getMonth() + 1).toString().padStart(2, '0');
                dateMap[dateStr] = `${day}-${month}`;
            }

            data.forEach(d => {
                const dateStr = d.date.toISOString().split('T')[0];
                if (grouped.hasOwnProperty(dateStr)) {
                    grouped[dateStr] += d.totalRevenue;
                }
            });
        }
        else if (mode === 'month') {
            const M = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            let from, to;
            if (dateFilter === 'currentMonth') {
                const today = new Date();
                from = new Date(today.getFullYear(), today.getMonth(), 1);
                to = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            } else if (dateFilter === 'customdate' && GDFromDate && GDToDate) {
                from = new Date(GDFromDate);
                to = new Date(GDToDate);
            } else {
                from = new Date(Math.min(...data.map(d => d.date.getTime())));
                to = new Date(Math.max(...data.map(d => d.date.getTime())));
            }

            // Initialize months between from and to
            const start = new Date(from.getFullYear(), from.getMonth(), 1);
            const end = new Date(to.getFullYear(), to.getMonth(), 1);
            while (start <= end) {
                const m = start.getMonth();
                const y = start.getFullYear();
                const key = `${y}-${m}`;
                grouped[m] = 0; // grouped by numeric month index
                dateMap[key] = `${M[m]} ${y}`; // label as "Jan 2025"
                start.setMonth(start.getMonth() + 1);
            }

            data.forEach(d => {
                const key = `${d.date.getFullYear()}-${d.date.getMonth()}`;
                if (grouped.hasOwnProperty(d.date.getMonth())) {
                    grouped[d.date.getMonth()] += d.totalRevenue;
                }
            });
        }
        else /* monthYear */ {
            data.forEach(d => {
                const k = `${d.date.getFullYear()}-${d.date.getMonth()}`;
                grouped[k] = (grouped[k] || 0) + d.totalRevenue;
            });
        }

        let values = [];
        let finalLabels = [];
        if (mode === 'hour') {
            // For hour/month: Keep all labels regardless of values
            finalLabels = [...labels];
            values = finalLabels.map((_, i) => grouped[i] || 0);
        }
        else if (mode === 'month') {
            const sortedKeys = Object.keys(dateMap).sort((a, b) => {
                const [y1, m1] = a.split(`-`).map(Number), [y2, m2] = b.split(`-`).map(Number);
                return y1 !== y2 ? y1 - y2 : m1 - m2;
            });
            finalLabels = sortedKeys.map(k => dateMap[k]);
            values = sortedKeys.map(k => {
                const m = Number(k.split('-')[1]);
                return grouped[m] || 0;
            });
        }
        else if (mode === 'day') {
            const sortedKeys = Object.keys(grouped).sort();
            finalLabels = sortedKeys.map(dateStr => dateMap[dateStr]);
            values = sortedKeys.map(dateStr => grouped[dateStr] || 0);
        }
        else { // monthYear
            const sortedKeys = Object.keys(grouped).sort((a, b) => {
                const [y1, m1] = a.split(`-`).map(Number), [y2, m2] = b.split(`-`).map(Number);
                return y1 !== y2 ? y1 - y2 : m1 - m2;
            });

            finalLabels = sortedKeys.map(k => {
                const [y, m] = k.split('-').map(Number);
                return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][m] + ' ' + y;
            });

            values = sortedKeys.map(k => grouped[k] || 0);
        }

        // Replace labels with final version
        labels = finalLabels;

        // 5) render
        window.revenueChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels, datasets: [{
                    label: 'Revenue', data: values,
                    borderColor: '#4caf50', backgroundColor: 'rgba(76,175,80,0.2)',
                    tension: 0.4, fill: true, pointRadius: 2
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                    x: { ticks: { color: '#555' }, grid: { display: false } },
                    y: { beginAtZero: true, ticks: { color: '#555' }, grid: { color: '#eee' } }
                },
                plugins: { legend: { labels: { color: '#444' } } }
            }
        });
    }


    // Customer chart—same logic, just swap totalRevenue→totalCustomers & color
    function renderCustomerChart(data) {
        const ctx = document.getElementById('customerChart').getContext('2d');
        if (window.customerChartInstance) {
            window.customerChartInstance.destroy();
        }

        // 1. Parse incoming date strings
        data.forEach(d => d.date = new Date(d.date));
        let dateFilter = $('#time-main-filter').val();

        // 2. Determine grouping mode
        let mode;
        if (!GDFromDate || !GDToDate || dateFilter === "all") {
            // ALL TIME: derive from data range
            const times = data.map(d => d.date.getTime());
            const minD = new Date(Math.min(...times));
            const maxD = new Date(Math.max(...times));
            const sameDay = minD.toDateString() === maxD.toDateString();
            const sameMonth = minD.getFullYear() === maxD.getFullYear() && minD.getMonth() === maxD.getMonth();
            const sameYear = minD.getFullYear() === maxD.getFullYear();

            if (sameDay) mode = 'hour';
            else if (sameMonth) mode = 'day';
            else if (sameYear) mode = 'month';
            else mode = 'monthYear';
        }
        else {
            // FILTERED: based on GDFromDate/GDToDate & dateFilter
            const from = new Date(GDFromDate),
                to = new Date(GDToDate);
            const sameDay = from.toDateString() === to.toDateString();
            const sameMonth = from.getFullYear() === to.getFullYear() && from.getMonth() === to.getMonth();
            const sameYear = from.getFullYear() === to.getFullYear();

            if (dateFilter === "today") mode = 'hour';
            else if (dateFilter === "7" || dateFilter === "30" || dateFilter === "currentMonth")
                mode = 'day';
            else /* customdate */ {
                if (sameDay) mode = 'hour';
                else if (sameMonth) mode = 'day';
                else if (sameYear) mode = 'month';
                else mode = 'monthYear';
            }
        }

        // 3. Build labels & group totals
        let labels = [], grouped = {};
        let dateMap = {}; // for day mode: DD-MM format
        if (mode === 'hour') {
            for (let h = 0; h < 24; h++) {
                labels.push(`${h}:00`);
                grouped[h] = 0;
            }
            data.forEach(d => grouped[d.date.getHours()] += d.totalCustomers);
        }
        else if (mode === 'day') {
            let from, to;
            if (dateFilter === "currentMonth") {
                const today = new Date();
                from = new Date(today.getFullYear(), today.getMonth(), 1);
                to = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            } else {
                from = new Date(GDFromDate);
                to = new Date(GDToDate);
            }

            for (let dt = new Date(from); dt <= to; dt.setDate(dt.getDate() + 1)) {
                const dateStr = dt.toISOString().split('T')[0]; // yyyy-MM-dd
                grouped[dateStr] = 0;
                // Changed to "DD-MM" format
                const day = dt.getDate().toString().padStart(2, '0');
                const month = (dt.getMonth() + 1).toString().padStart(2, '0');
                dateMap[dateStr] = `${day}-${month}`;
            }

            data.forEach(d => {
                const dateStr = d.date.toISOString().split('T')[0];
                if (grouped.hasOwnProperty(dateStr)) {
                    grouped[dateStr] += d.totalCustomers;
                }
            });
        }
        else if (mode === 'month') {
            const M = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            for (let m = 0; m < 12; m++) {
                labels.push(M[m]);
                grouped[m] = 0;
            }
            data.forEach(d => grouped[d.date.getMonth()] += d.totalCustomers);
        }
        else {
            data.forEach(d => {
                const k = `${d.date.getFullYear()}-${d.date.getMonth()}`;
                grouped[k] = (grouped[k] || 0) + d.totalCustomers;
            });
        }

        let values = [];
        let finalLabels = [];
        if (mode === 'hour' || mode === 'month') {
            // For hour/month: Keep all labels regardless of values
            finalLabels = [...labels];
            values = finalLabels.map((_, i) => grouped[i] || 0);
        }
        else if (mode === 'day') {
            const sortedKeys = Object.keys(grouped).sort();
            finalLabels = sortedKeys.map(dateStr => dateMap[dateStr]);
            values = sortedKeys.map(dateStr => grouped[dateStr] || 0);
        }
        else { // monthYear
            const sortedKeys = Object.keys(grouped).sort((a, b) => {
                const [y1, m1] = a.split(`-`).map(Number), [y2, m2] = b.split(`-`).map(Number);
                return y1 !== y2 ? y1 - y2 : m1 - m2;
            });

            finalLabels = sortedKeys.map(k => {
                const [y, m] = k.split('-').map(Number);
                return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][m] + ' ' + y;
            });

            values = sortedKeys.map(k => grouped[k] || 0);
        }

        // Replace labels with final version
        labels = finalLabels;


        // 5. Render Chart.js
        window.customerChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [{
                    label: 'Customers',
                    data: values,
                    borderColor: '#2196f3',
                    backgroundColor: 'rgba(33, 150, 243, 0.2)',
                    tension: 0.4,
                    fill: true,
                    pointRadius: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { ticks: { color: '#555' }, grid: { display: false } },
                    y: { beginAtZero: true, ticks: { color: '#555' }, grid: { color: '#eee' } }
                },
                plugins: { legend: { labels: { color: '#444' } } }
            }
        });
    }

    $(document).ready(function () {

        const today = new Date();
        const maxDate = formatDate(today);

        // Set max date to today for both inputs
        $("#FromDate").attr("max", maxDate);
        $("#ToDate").attr("max", maxDate);

        // When FromDate changes
        $("#FromDate").on("change", function () {
            const fromDate = $(this).val();
            $("#ToDate").attr("min", fromDate); // To date must be on/after From date
        });

        // When ToDate changes
        $("#ToDate").on("change", function () {
            const toDate = $(this).val();
            $("#FromDate").attr("max", toDate); // From date must be on/before To date
        });

        $('#customDateModal').on('show.bs.modal', function () {
            // Set max date to today for both inputs
            $("#FromDate").attr("max", maxDate);
            $("#ToDate").attr("max", maxDate).removeAttr("min");
        });


        loadDashboard();



        function loadDashboard() {

            $.ajax({
                url: "/Home/Dashboard",
                type: "GET",
                data: {
                    fromDate: GDFromDate,
                    toDate: GDToDate
                },
                success: function (data) {
                    $(".dashboard-partial").html(data);
                },
                error: function () {
                    alert("Failed to load data.");
                }
            });
        }



        $("#time-main-filter").on("change", function () {

            $("#FromDate").val("");
            $("#ToDate").val("");

            let dateFilter = $(this).val();

            let fromDate = null;
            let toDate = null; // Set to null for "All" option

            let today = new Date();


            if (dateFilter === "7") {
                fromDate = new Date(today);
                fromDate.setDate(today.getDate() - 7);
                toDate = today;
            } else if (dateFilter === "30") {
                fromDate = new Date(today);
                fromDate.setDate(today.getDate() - 30);
                toDate = today;
            } else if (dateFilter === "currentMonth") {
                fromDate = new Date(Date.UTC(today.getFullYear(), today.getMonth(), 1)); // First day of the current month
                toDate = today;
            } else if (dateFilter === "today") {// Today
                fromDate = today;
                toDate = today;
            }
            else if (dateFilter === "customdate") {// Custom Date: Open modal
                $("#customDateModal").modal("show");
                $("#time-main-filter").val("0");
                return;// Stop execution here
            }

            // Convert dates to YYYY-MM-DD format for PostgreSQL
            fromDate = fromDate ? fromDate.toISOString().slice(0, 19).replace("T", " ") : null;
            toDate = toDate ? toDate.toISOString().slice(0, 19).replace("T", " ") : null;

            GDFromDate = fromDate;
            GDToDate = toDate;

            loadDashboard();

        });

        $("#serachDate").on("click", function () {
            if ($("#FromDate").val() > $("#ToDate").val()) {
                toastr.error("To date should be greater than from date");
                return;
            }
            else {
                GDFromDate = $("#FromDate").val();
                GDToDate = $("#ToDate").val();
                loadDashboard();
                $("#customDateModal").modal("hide");
            }
        });




    });

</script>